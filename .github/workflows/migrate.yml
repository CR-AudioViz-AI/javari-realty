name: Database Migration

on:
  workflow_dispatch:
    inputs:
      action:
        description: Type MIGRATE to confirm
        required: true

jobs:
  migrate:
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'MIGRATE'
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install pg
        run: npm install pg
        
      - name: Resolve IPv4 and Run Migration
        env:
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        run: |
          # Get IPv4 address first
          IPV4=$(dig +short A db.kteobfyferrukqeolofj.supabase.co | head -1)
          echo "Resolved IPv4: $IPV4"
          
          if [ -z "$IPV4" ]; then
            echo "Failed to resolve IPv4!"
            exit 1
          fi
          
          export DB_HOST=$IPV4
          
          node -e "
          const { Client } = require('pg');
          
          const client = new Client({
            host: process.env.DB_HOST,
            port: 5432,
            user: 'postgres',
            password: process.env.PGPASSWORD,
            database: 'postgres',
            ssl: { rejectUnauthorized: false }
          });

          async function run() {
            console.log('Connecting to', process.env.DB_HOST);
            await client.connect();
            console.log('Connected!');
            
            // Simple test first
            const ver = await client.query('SELECT version()');
            console.log('PostgreSQL:', ver.rows[0].version.substring(0, 50));
            
            // Run migration
            console.log('Running migration...');
            
            await client.query(\\\`CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS profiles (id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, email TEXT UNIQUE NOT NULL, full_name TEXT, phone TEXT, role TEXT DEFAULT 'client', avatar_url TEXT, license_number TEXT, license_state TEXT, brokerage TEXT, bio TEXT, specialties TEXT[], service_areas TEXT[], years_experience INTEGER, is_admin BOOLEAN DEFAULT false, is_active BOOLEAN DEFAULT true, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS properties (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), agent_id UUID REFERENCES profiles(id), mls_id TEXT, title TEXT NOT NULL, description TEXT, property_type TEXT DEFAULT 'single_family', status TEXT DEFAULT 'active', address TEXT NOT NULL, city TEXT NOT NULL, state TEXT NOT NULL, zip_code TEXT NOT NULL, county TEXT, latitude NUMERIC(10, 7), longitude NUMERIC(10, 7), price NUMERIC(12, 2) NOT NULL, bedrooms INTEGER, bathrooms NUMERIC(3, 1), sqft INTEGER, lot_size NUMERIC(10, 2), year_built INTEGER, features TEXT[], photos TEXT[], primary_image_url TEXT, virtual_tour_url TEXT, is_featured BOOLEAN DEFAULT false, listed_date DATE, sold_date DATE, sold_price NUMERIC(12, 2), created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS realtor_customers (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), auth_user_id UUID REFERENCES auth.users(id), agent_id UUID REFERENCES profiles(id), email TEXT NOT NULL, full_name TEXT NOT NULL, phone TEXT, preferred_contact TEXT DEFAULT 'email', budget_min NUMERIC(12, 2), budget_max NUMERIC(12, 2), preferred_locations TEXT[], property_types TEXT[], notes TEXT, status TEXT DEFAULT 'active', source TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS realtor_leads (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), agent_id UUID REFERENCES profiles(id), first_name TEXT, last_name TEXT, email TEXT, phone TEXT, status TEXT DEFAULT 'new', source TEXT, budget_min NUMERIC(12, 2), budget_max NUMERIC(12, 2), preferred_locations TEXT[], property_type TEXT, notes TEXT, last_contact_date TIMESTAMPTZ, next_followup_date TIMESTAMPTZ, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS saved_properties (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, property_id UUID REFERENCES properties(id) ON DELETE CASCADE, notes TEXT, rating INTEGER, created_at TIMESTAMPTZ DEFAULT NOW(), UNIQUE(user_id, property_id))\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS showings (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), property_id UUID REFERENCES properties(id), agent_id UUID REFERENCES profiles(id), customer_id UUID REFERENCES realtor_customers(id), scheduled_at TIMESTAMPTZ NOT NULL, duration_minutes INTEGER DEFAULT 30, status TEXT DEFAULT 'pending', notes TEXT, feedback TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS vendors (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), agent_id UUID NOT NULL REFERENCES profiles(id), business_name TEXT NOT NULL, contact_name TEXT, email TEXT, phone TEXT, website TEXT, city TEXT, state TEXT, category TEXT NOT NULL, description TEXT, notes TEXT, is_preferred BOOLEAN DEFAULT false, is_active BOOLEAN DEFAULT true, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS organizations (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT NOT NULL, slug TEXT UNIQUE, logo_url TEXT, contact_email TEXT, contact_phone TEXT, address TEXT, city TEXT, state TEXT, zip TEXT, website TEXT, is_active BOOLEAN DEFAULT true, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            await client.query(\\\`CREATE TABLE IF NOT EXISTS realtor_messages (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), conversation_id UUID, sender_id UUID REFERENCES auth.users(id), recipient_id UUID REFERENCES auth.users(id), property_id UUID REFERENCES properties(id), subject TEXT, content TEXT NOT NULL, is_read BOOLEAN DEFAULT false, created_at TIMESTAMPTZ DEFAULT NOW())\\\`);
            
            // Enable RLS
            await client.query(\\\`ALTER TABLE profiles ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE properties ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE realtor_customers ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE realtor_leads ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE saved_properties ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE showings ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE vendors ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE organizations ENABLE ROW LEVEL SECURITY\\\`);
            await client.query(\\\`ALTER TABLE realtor_messages ENABLE ROW LEVEL SECURITY\\\`);
            
            // Policies
            await client.query(\\\`DROP POLICY IF EXISTS service_role_profiles ON profiles; CREATE POLICY service_role_profiles ON profiles FOR ALL USING (current_setting('request.jwt.claims', true)::json->>'role' = 'service_role')\\\`);
            await client.query(\\\`DROP POLICY IF EXISTS public_read_profiles ON profiles; CREATE POLICY public_read_profiles ON profiles FOR SELECT USING (true)\\\`);
            await client.query(\\\`DROP POLICY IF EXISTS service_role_properties ON properties; CREATE POLICY service_role_properties ON properties FOR ALL USING (current_setting('request.jwt.claims', true)::json->>'role' = 'service_role')\\\`);
            await client.query(\\\`DROP POLICY IF EXISTS public_read_properties ON properties; CREATE POLICY public_read_properties ON properties FOR SELECT USING (true)\\\`);
            
            // Indexes
            await client.query(\\\`CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email)\\\`);
            await client.query(\\\`CREATE INDEX IF NOT EXISTS idx_properties_status ON properties(status)\\\`);
            await client.query(\\\`CREATE INDEX IF NOT EXISTS idx_properties_agent ON properties(agent_id)\\\`);
            
            // Trigger function
            await client.query(\\\`CREATE OR REPLACE FUNCTION update_updated_at_column() RETURNS TRIGGER AS \\\\\\$\\\\\\$ BEGIN NEW.updated_at = NOW(); RETURN NEW; END; \\\\\\$\\\\\\$ LANGUAGE plpgsql\\\`);
            
            // Auto-create profile
            await client.query(\\\`CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS \\\\\\$\\\\\\$ BEGIN INSERT INTO public.profiles (id, email, full_name, role) VALUES (NEW.id, NEW.email, COALESCE(NEW.raw_user_meta_data->>'full_name', ''), 'client') ON CONFLICT (id) DO NOTHING; RETURN NEW; END; \\\\\\$\\\\\\$ LANGUAGE plpgsql SECURITY DEFINER\\\`);
            await client.query(\\\`DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users; CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user()\\\`);
            
            // Seed profiles from auth users
            await client.query(\\\`INSERT INTO profiles (id, email, full_name, role) SELECT id, email, COALESCE(raw_user_meta_data->>'full_name', ''), CASE WHEN email LIKE '%tony%' OR email LIKE '%laura%' THEN 'realtor' ELSE 'client' END FROM auth.users ON CONFLICT (id) DO UPDATE SET role = CASE WHEN EXCLUDED.email LIKE '%tony%' OR EXCLUDED.email LIKE '%laura%' THEN 'realtor' ELSE profiles.role END\\\`);
            
            // Verify
            const tables = await client.query(\\\"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('profiles', 'properties', 'realtor_customers', 'realtor_leads', 'saved_properties', 'showings', 'vendors', 'organizations', 'realtor_messages') ORDER BY table_name\\\");
            console.log('Tables created:', tables.rows.map(r => r.table_name).join(', '));
            
            const profiles = await client.query('SELECT COUNT(*) as cnt FROM profiles');
            console.log('Profiles seeded:', profiles.rows[0].cnt);
            
            await client.end();
            console.log('Migration complete!');
          }
          
          run().catch(e => { console.error('Error:', e.message); process.exit(1); });
          "
